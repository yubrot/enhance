# Week 16-17: System Catalog

> Store table/column definitions as heap tuples with MVCC. Bootstrap reserved catalog tables (pg_class, pg_attribute equivalent). Implement auto-increment sequences for SERIAL columns.

# This Step I Learned

## The Bootstrap Problem

The system catalog stores metadata about all tables—including itself. This creates a circular dependency: to read the catalog, you need to know its schema, but the schema is stored in the catalog. PostgreSQL solves this with **hardcoded schemas** for system tables and a **bootstrap transaction** that inserts the initial metadata.

Our implementation follows the same pattern:

```
Bootstrap Sequence:
1. Allocate superblock (page 0)
2. Allocate catalog heap pages (pages 1-3)
3. Hardcode catalog schemas in Rust code
4. Begin bootstrap transaction (TxId = 1)
5. Insert catalog table definitions into sys_tables
6. Insert catalog column definitions into sys_columns
7. Commit bootstrap transaction
8. Flush all pages
```

Once bootstrap completes, the catalog is self-describing—metadata about `sys_tables` exists as tuples in `sys_tables` itself.

## Architecture: Three-Table Catalog

We implement three system tables, analogous to PostgreSQL's pg_class, pg_attribute, and pg_sequence:

```
┌──────────────────┐       ┌──────────────────┐       ┌──────────────────┐
│   sys_tables     │       │   sys_columns    │       │  sys_sequences   │
├──────────────────┤       ├──────────────────┤       ├──────────────────┤
│ table_id   INT4  │◄──────│ table_id   INT4  │       │ seq_id     INT4  │
│ table_name TEXT  │  FK   │ column_num INT4  │       │ seq_name   TEXT  │
│ first_page INT8  │       │ column_name TEXT │       │ next_val   INT8  │
└──────────────────┘       │ type_oid   INT4  │       └──────────────────┘
                           │ seq_id     INT4  │───────────────┘
                           └──────────────────┘     FK (for SERIAL)
```

Each table occupies a single heap page for simplicity. Multi-page catalog tables will be supported in Step 15 with the Free Space Map.

## Superblock: Database Metadata

Page 0 holds the **superblock**—metadata about the database itself:

```rust
struct Superblock {           // 48 bytes total
    magic: u32,               // "ENHN" (0x454E484E)
    version: u32,             // Format version
    sys_tables_page: PageId,  // Page ID of sys_tables
    sys_columns_page: PageId, // Page ID of sys_columns
    sys_sequences_page: PageId,
    next_table_id: u32,       // ID allocator
    next_seq_id: u32,         // ID allocator
    // 8 bytes reserved
}
```

The magic number enables detection of non-enhance files or corrupted databases. The version field allows future format migrations.

## MVCC Integration

Catalog tuples use the same MVCC tuple headers as user data. This means:

- **CREATE TABLE** inserts with xmin = current TxId, visible only after commit
- **Concurrent DDL** respects transaction isolation
- **Catalog cache** is invalidated on DDL operations

The `get_table` and `get_columns` methods apply visibility rules via the snapshot:

```rust
for (slot_id, header, record) in page.scan(&SYS_TABLES_SCHEMA) {
    if !snapshot.is_tuple_visible(&header, &tx_manager) {
        continue;  // Skip invisible tuples
    }
    // Process visible tuple...
}
```

## Sequences for SERIAL Columns

SERIAL columns require auto-increment behavior. Unlike regular DML, **sequences are not rolled back on transaction abort**—this prevents gaps from blocking concurrent inserts (PostgreSQL behavior).

The implementation:
1. `CREATE TABLE` with SERIAL column creates a linked sequence in sys_sequences
2. The column's `seq_id` field references the sequence
3. On INSERT, the executor calls `catalog.nextval(seq_id)` for SERIAL columns
4. `nextval` increments the sequence value unconditionally (no MVCC rollback)

## Database Orchestrator

A new `Database` type unifies BufferPool, TransactionManager, and Catalog:

```rust
pub struct Database<S: Storage, R: Replacer> {
    pool: Arc<BufferPool<S, R>>,
    tx_manager: Arc<TransactionManager>,
    catalog: Catalog<S, R>,
}

impl Database {
    pub async fn open(storage: S, pool_size: usize) -> Result<Self, DatabaseError> {
        // Bootstrap or open existing database
        if pool.page_count() == 0 {
            Catalog::bootstrap(...)
        } else {
            Catalog::open(...)
        }
    }
}
```

This provides a clean separation: connection handlers interact with `Database`, not individual components.

## Catalog Cache

Scanning catalog pages on every query is expensive. A write-through cache accelerates lookups:

```rust
struct CatalogCache {
    tables_by_name: RwLock<HashMap<String, TableInfo>>,
    columns_by_table: RwLock<HashMap<u32, Vec<ColumnInfo>>>,
}
```

Cache entries are populated on first access (lazy loading) and invalidated on DDL operations. For read-heavy workloads, this reduces catalog page fetches to once per table.

# Looking Forward

## Immediate Dependencies

- **Step 10 (Basic Executor)**: Uses catalog for schema lookup, scans heap pages with MVCC visibility
- **Step 11 (DML Operations)**: INSERT uses `nextval` for SERIAL columns, catalog provides table metadata for page allocation

## Deferred: DROP TABLE

DROP TABLE is not implemented—it requires:
1. Marking sys_tables/sys_columns tuples as deleted (set xmax)
2. Invalidating cache entries
3. Reclaiming heap pages (depends on Step 15: VACUUM & FSM)

## Deferred: ALTER TABLE

Schema modifications (ADD COLUMN, DROP COLUMN) require updating sys_columns. This is straightforward but not needed until after basic query execution works.

## Deferred: Multi-Page Catalog

Each catalog table is limited to a single page (~8KB). With ~100 bytes per table entry, this allows ~80 user tables. Production systems:
- Chain multiple pages per catalog table
- Use Step 15's FSM to find pages with free space
- May use indexes on catalog tables for large schemas

## Production Readiness Gaps

### Concurrent CREATE TABLE

While visibility rules work correctly, two concurrent `CREATE TABLE` with the same name could both succeed if the duplicate check happens before either commits. Production systems use:
- Catalog-level locking (PostgreSQL's relation-level locks)
- Index-based uniqueness constraints (Step 17)

### Sequence Persistence

`nextval` updates the sequence in-place using a simplified update pattern (mark old tuple deleted, insert new). A crash between mark-deleted and insert-new loses the sequence state. Full WAL (Step 13) is needed for durability.

### Cache Invalidation Across Connections

The current cache is per-Catalog instance. In a multi-connection scenario, DDL in one connection doesn't invalidate caches in others. Solutions:
- Shared cache with broadcast invalidation
- Check catalog version/timestamp on cache hit
- Accept stale reads (PostgreSQL's `pg_catalog` caching strategy)

### ID Allocator Persistence

`next_table_id` and `next_seq_id` are persisted in the superblock, but increments aren't durably committed until `flush_superblock()`. A crash during table creation could reuse IDs. WAL will ensure ID allocation durability.
