# Week 20-21: DML Operations

> INSERT (set xmin), DELETE (set xmax), UPDATE (delete + insert as new version). Implement type coercion for mixed-type expressions.

# This Step I Learned

## PostgreSQL-Style MVCC Updates

The most important architectural decision was adopting PostgreSQL's MVCC update model: **UPDATE = DELETE + INSERT**. Rather than modifying tuples in-place, we:

1. Mark the old tuple as deleted by setting `xmax = current_txid`
2. Insert a new tuple with the updated values and `xmin = current_txid`

```
Before UPDATE:
┌────────────────────────────────────────┐
│  Tuple (xmin=100, xmax=0)              │
│  [id=1, name="Alice", age=30]          │
└────────────────────────────────────────┘

After UPDATE users SET age = 31 WHERE id = 1: (txid=200)
┌────────────────────────────────────────┐
│  Tuple (xmin=100, xmax=200)  ← deleted │
│  [id=1, name="Alice", age=30]          │
├────────────────────────────────────────┤
│  Tuple (xmin=200, xmax=0)    ← new     │
│  [id=1, name="Alice", age=31]          │
└────────────────────────────────────────┘
```

This design has key advantages:
- **Rollback is free**: On abort, we simply leave both tuples—visibility rules hide them automatically
- **Concurrent readers never block**: Other transactions see the old version until we commit
- **No UNDO log needed**: Old versions persist in the heap until VACUUM

The trade-off is heap bloat—UPDATE-heavy workloads create many dead tuples. Step 15 (VACUUM) will reclaim this space.

## Self-Referencing UPDATE Expressions

A subtle requirement: `SET age = age + 1` must evaluate `age` from the **old** tuple, not the new one. Our implementation handles this by evaluating all SET expressions against the original tuple before applying changes:

```rust
// Build new tuple values (start with old values for self-reference support)
let mut new_values = record.values.clone();

// Apply SET assignments - evaluate against OLD tuple values
for (col_idx, expr) in &assignment_map {
    let value = evaluate(expr, &record.values, &columns)?;  // ← OLD values
    new_values[*col_idx] = value;
}
```

If we evaluated against `new_values` progressively, `SET a = b, b = a` would swap incorrectly—the second assignment would see `a`'s new value.

## The RETURNING Clause

RETURNING transforms DML into read-write operations, eliminating round trips for common patterns:

```sql
-- Instead of: INSERT ... ; SELECT id FROM users WHERE ...
INSERT INTO users (name) VALUES ('Alice') RETURNING id;

-- Returns the deleted rows
DELETE FROM users WHERE status = 'inactive' RETURNING *;

-- Returns new values after update
UPDATE users SET age = age + 1 RETURNING age;
```

Implementation insight: RETURNING for DELETE returns **old** values (what was deleted), while RETURNING for UPDATE returns **new** values (what was created). This matches PostgreSQL semantics and user expectations.

```rust
// DELETE: capture old values BEFORE marking as deleted
if let Some(ref returning) = stmt.returning {
    let tuple = evaluate_returning(returning, &record.values, &columns)?;
    returning_tuples.push(tuple);
}
header.xmax = txid;  // Then mark deleted

// UPDATE: return NEW values from the inserted tuple
let new_record = Record::new(new_values.clone());
page.insert(&new_record, txid, cid)?;
if let Some(ref returning) = stmt.returning {
    let tuple = evaluate_returning(returning, &new_values, &columns)?;  // ← new
    returning_tuples.push(tuple);
}
```

## Type Coercion Strategy

SQL requires implicit type conversion for mixed-type operations. Our coercion follows PostgreSQL semantics with a "promote to wider type" strategy:

```
Coercion Direction:
INT2 → INT4 → INT8 → FLOAT4 → FLOAT8
                ↓         ↓
              TEXT      TEXT
```

Key rules:
1. **NULL coerces to any type** (stays NULL)
2. **Narrower integers widen** without loss: Int16 → Int32 → Int64
3. **Integers promote to floats** for mixed arithmetic
4. **Any type coerces to TEXT** via string conversion
5. **TEXT parses to numbers** when target is numeric

```rust
// Coercing Int64 to Int32 column: check bounds
fn coerce_to_int32(value: Value) -> Result<Value, ExecutorError> {
    match value {
        Value::Int64(n) => {
            if n >= i32::MIN as i64 && n <= i32::MAX as i64 {
                Ok(Value::Int32(n as i32))
            } else {
                Err(ExecutorError::InvalidOperation {
                    message: format!("integer {} out of range for INTEGER", n),
                })
            }
        }
        // ...
    }
}
```

The bounds checking on narrowing conversions prevents silent data truncation—a common source of bugs in systems that allow implicit narrowing.

## DML vs. Query Executors

Unlike SELECT (which uses the Volcano iterator model), DML operations are **bulk operations**:

```rust
// SELECT: iterator pattern
async fn next(&mut self) -> Result<Option<Tuple>, ExecutorError>

// INSERT/UPDATE/DELETE: batch result
pub struct InsertResult {
    pub row_count: u64,
    pub returning_tuples: Vec<Vec<Value>>,
    pub returning_schema: Vec<OutputColumn>,
}
```

Design rationale: DML affects multiple tuples atomically within a single command. Returning a row count and optional RETURNING data is sufficient—there's no need for tuple-by-tuple iteration. This also simplifies page latch management (hold write latch for the entire operation).

# Looking Forward

## Immediate Dependencies

- **Step 12 (Sort & Aggregation)**: Will use the same expression evaluation infrastructure for aggregate functions
- **Step 13 (WAL)**: DML operations must log before modifying pages; current changes aren't durable

## Deferred: Multi-Valued INSERT

Parsing supports `INSERT INTO t VALUES (1), (2), (3)` but each row is processed sequentially. Batching multiple inserts into a single page operation would improve throughput.

## Deferred: SERIAL Sequence Visibility

The test suite notes a bug: `nextval` doesn't use MVCC visibility, so concurrent inserts may see stale sequence values. The correct fix (Step 9 scope) requires making `sys_sequences` updates MVCC-aware while preserving the "no rollback" semantics.

## Production Readiness Gaps

### Write Skew Prevention

Current implementation doesn't prevent write skew anomalies. Two transactions could both read row R, pass a WHERE check, and both update R—violating intended constraints. Solutions:
- SELECT FOR UPDATE (Step 20) for explicit locking
- SERIALIZABLE isolation level (out of scope per ADR)

### Page Space Exhaustion

UPDATE operations insert new tuples on the same page. If the page is full, the operation fails. Production systems:
- Use FSM (Step 15) to find pages with free space
- Support multi-page tables with overflow pages

### Bulk DML Performance

Each row modification is a separate heap operation. Bulk INSERT could benefit from:
- Batch allocation of slots
- Reduced latch acquisition overhead
- Copy-based insertion for large imports

### Constraint Enforcement

No CHECK constraints, FOREIGN KEY validation, or NOT NULL enforcement exists. Currently:
- SERIAL columns auto-generate values but don't enforce uniqueness
- NULL can be inserted into any column
- No referential integrity checks

Step 17 (Constraints) will add PRIMARY KEY and UNIQUE via B+Tree index-based enforcement.
