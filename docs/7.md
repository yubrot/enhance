# Week 12-13: Lexer & Parser

> Tokenize SQL strings. Implement recursive descent parser for CREATE TABLE, INSERT, SELECT, UPDATE, DELETE. Design AST structure.

# This Step I Learned

## Parser: Recursive Descent with Precedence Climbing

The SQL parser combines two techniques:

1. **Recursive descent** for statements and structural elements (SELECT clauses, CREATE TABLE columns)
2. **Precedence climbing** for expression parsing (operator precedence, associativity)

## Lexer: Iterator-Based Tokenization

The lexer implements `Iterator<Item = Token>`, producing tokens on demand rather than tokenizing the entire input upfront. Key decisions:

### Error Tokens Instead of Exceptions

Lexical errors (unterminated strings, invalid characters) produce `TokenKind::Error` tokens rather than failing immediately:

```rust
TokenKind::Error(String)  // e.g., "unterminated string literal"
```

This allows the parser to report errors with full context. The parser can continue past errors to potentially report multiple issues, though our current implementation stops at the first error.

# Looking Forward

## Production Readiness Gaps

### Error Recovery

The parser stops at the first error. Production parsers implement:

- **Synchronization**: Skip to known recovery points (`;`, `FROM`, `WHERE`)
- **Error productions**: Grammar rules that match common mistakes
- **Multiple error reporting**: Collect errors and continue parsing

### Prepared Statement Parameters

We support positional parameters (`$1`, `$2`) but not:

- Named parameters (`:name`)
- Question mark placeholders (`?`)
- Type hints for parameters

## Future Steps

The parser produces an AST that's consumed by the executor (Step 10). Before execution, several transformations are needed:

- **Name resolution**: Map identifiers to catalog entries
- **Type checking**: Verify operator/function argument types
- **Query rewriting**: Expand views, apply constant folding

These are typically part of a "semantic analysis" or "planning" phase between parsing and execution. Our minimal design will handle these inline during execution, trading separation of concerns for simplicity.
