# Week 14-15: MVCC Core

> Transaction manager (TxId allocation, active transaction tracking, commit/abort state machine), tuple header extension (xmin/xmax/cid/infomask), Snapshot structure, visibility rules (`HeapTupleSatisfiesMVCC`).

# This Step I Learned

## HeapPage: MVCC-Aware Storage

The heap page was refactored to separate concerns:

```
SlottedPage (internal)      HeapPage (public)
──────────────────────      ─────────────────
Raw bytes in slots      ->  TupleHeader + Record
insert(data)                insert(record, xmin, cmin)
get(slot_id) -> bytes       get(slot_id, schema) -> (TupleHeader, Record)
                            update_header(slot_id, header)
```

This abstraction makes MVCC transparent to higher layers. The `TupleHeader` prepended to every record contains versioning metadata (xmin, xmax, etc.) that enables multi-version concurrency control, as explained below.

## MVCC: Solving the Concurrency Problem

Concurrent reads and writes to the same data create a fundamental tension: readers block writers (or vice versa) if we use simple locks. MVCC (Multi-Version Concurrency Control) solves this by allowing **multiple versions of each tuple to exist simultaneously**. Readers see a consistent snapshot while writers create new versions.

### TxId: Transaction Identity

Every transaction is assigned a sequential **TxId** (starting from 1; 0 is reserved as INVALID).

The TransactionManager handles TxId allocation and state tracking (simplified; actual implementation uses `Mutex` for thread safety):

```rust
struct TransactionManager {
    next_txid: u64,                           // Next ID to allocate
    active_txids: Vec<TxId>,                  // Currently running transactions
    tx_states: HashMap<TxId, TxState>,        // InProgress / Committed / Aborted
}
```

- `begin() -> TxId`: Allocate TxId, add to active list, mark as InProgress
- `commit(txid)`: Transition to Committed, remove from active list
- `abort(txid)`: Transition to Aborted, remove from active list

### TupleHeader: Who Created, Who Deleted

Every row carries a **TupleHeader** that records "who created it (xmin)" and "who deleted it (xmax)":

| Field    | Size    | Purpose                                                     |
| -------- | ------- | ----------------------------------------------------------- |
| xmin     | 8 bytes | TxId that created this tuple version                        |
| xmax     | 8 bytes | TxId that deleted this version (INVALID if not deleted)     |
| cmin     | 4 bytes | Command ID when inserted (for intra-transaction visibility) |
| cmax     | 4 bytes | Command ID when deleted                                     |
| infomask | 2 bytes | Hint bits for commit/abort status (explained below)         |

DML operations modify these fields:

- **INSERT**: Creates a new tuple with `xmin = current TxId`, `xmax = INVALID`
- **DELETE**: Sets `xmax = current TxId` on the existing tuple (marks it as "deleted by me")
- **UPDATE**: is represented as **INSERT + DELETE**

### Snapshot: When Am I Looking?

To achieve consistent reads (transaction isolation), we need to capture "when" a query is observing the database. The **Snapshot** type represents this point-in-time view.

```rust
struct Snapshot {
    xmin: TxId,
    xmax: TxId,
    xip: Vec<TxId>,
    current_txid: TxId,
    current_cid: CommandId,
}
```

The Snapshot's `xmin` and `xmax` (not to be confused with TupleHeader's xmin/xmax) define a visibility window. We need all three fields because **transactions don't finish in the order they started**—a later transaction may commit before an earlier one:

- **xmin**: The oldest active TxId when the snapshot was taken. All transactions with `txid < xmin` have already finished, so we only need to check if they committed (visible) or aborted (invisible).
- **xmax**: The next TxId that will be allocated. All transactions with `txid >= xmax` started after this snapshot—they are invisible.
- **xip**: The list of transactions that were in-progress at snapshot time. Even if they commit later, their changes remain invisible to this snapshot.

```
TxId timeline:
──────────────────────────────────────────────────────►
     │              │                   │
     │   Past       │     Present       │    Future
     │  (visible)   │    (check xip)    │  (invisible)
     │              │                   │
     0             xmin                xmax
```

For READ COMMITTED isolation, a new snapshot is created for each statement. This means concurrent commits become visible between statements within the same transaction.

A tuple is visible if:

1. **xmin is visible**: The inserting transaction committed before our snapshot
2. **xmax is NOT visible**: Either not deleted, or the deleting transaction hasn't committed before our snapshot

```rust
impl Snapshot {
    fn is_tuple_visible(&self, header: &TupleHeader, tx_manager: &TransactionManager) -> bool {
        self.is_inserted(header, tx_manager) && !self.is_deleted(header, tx_manager)
    }
}
```

#### Self-Visibility (Within Same Transaction)

Within a single transaction, multiple statements execute sequentially.
The **CommandId** (cid) tracks this ordering, incrementing with each statement.

```sql
BEGIN;
INSERT INTO t VALUES (1);  -- cid=0
UPDATE t SET x = 2;        -- cid=1, must see the INSERT
SELECT * FROM t;           -- cid=2, must see both changes
COMMIT;
```

Without cid, an UPDATE scanning the table could see rows it just inserted in the same statement, causing infinite loops or duplicate processing.

Special rules apply when the current transaction is xmin or xmax:

- Tuple inserted by current transaction: visible only if `cmin < current_cid`
- Tuple deleted by current transaction: deleted only if `cmax < current_cid`

This allows a transaction to see its own uncommitted changes while maintaining consistency across commands.

### Infomask: Hint Bits for Performance

Checking transaction state requires a hash lookup. Once a transaction completes, its status never changes, so we cache this in the tuple header:

```rust
struct Infomask {
    const XMIN_COMMITTED: u16 = 1 << 0;
    const XMIN_ABORTED: u16 = 1 << 1;
    const XMAX_COMMITTED: u16 = 1 << 2;
    const XMAX_ABORTED: u16 = 1 << 3;
}
```

We'll follow the **PostgreSQL's lazy hint bit strategy**: Hint bits are NOT set during abort (which would require tracking all written tuples). Instead:

- Readers set hint bits when they first encounter tuples (Step 10: SeqScan)
- VACUUM ensures all tuples eventually get hint bits (Step 15)

## Design Decisions (vs PostgreSQL)

### 64-bit TxId

PostgreSQL uses 32-bit TxIds, requiring VACUUM FREEZE to prevent wraparound (~4 billion transactions). We use 64-bit TxIds, eliminating this concern entirely:

| TPS       | Time to exhaust 2^63 |
| --------- | -------------------- |
| 1,000,000 | 292,000 years        |

This simplifies the implementation by removing the need for frozen transaction IDs and age-based vacuum triggers.

### Separate cmin/cmax

PostgreSQL reuses a single 4-byte field (`t_cid`) for both cmin and cmax, since a tuple is either being inserted OR deleted at any given moment, never both simultaneously. We keep them as separate fields (8 bytes total) for clarity, accepting the space overhead for learning purposes.

# Looking Forward

## Future Steps

This step's implementation is tightly coupled with subsequent steps:

- **Step 9 (System Catalog)**: Uses MVCC for catalog tuples, enabling concurrent DDL
- **Step 10 (Executor)**: SeqScan with visibility filtering, hint bit setting
- **Step 11 (DML)**: INSERT sets xmin, DELETE sets xmax, UPDATE = DELETE + INSERT

## Deferred: Hint Bit Setting

Visibility checks currently read transaction state but don't update hint bits in the tuple header. This will be added in Step 10 (SeqScan) when we have an executor that can write back to pages.

## Deferred: Transaction State Persistence (CLOG)

Transaction state is stored in-memory and lost on restart. A persistent "commit log" (CLOG) is needed for durability:

```
// Current (volatile)
tx_states: Mutex<HashMap<TxId, TxState>>

// Production
clog: PersistentBitmap  // 2 bits per TxId: 00=in_progress, 01=committed, 10=aborted
```

**Note**: CLOG is distinct from WAL (Write-Ahead Log):

| Structure     | Purpose                     | Access Pattern        |
| ------------- | --------------------------- | --------------------- |
| WAL (Step 13) | Redo log for crash recovery | Sequential append     |
| CLOG          | Transaction commit status   | Random access by TxId |

Both are needed: WAL ensures durability of data changes, while CLOG provides fast lookup of transaction outcomes for visibility checks. PostgreSQL stores CLOG in `pg_xact/` directory.

Until CLOG is implemented, a crash leaves committed transactions unrecoverable.

## Deferred: Transaction State GC

Currently `tx_states` never removes entries. As TxIds grow, this map grows unbounded. This requires:

- Determine oldest active snapshot (`oldestXmin`)
- GC transaction states where `txid < oldestXmin` (all observers have seen the outcome)
- This depends on CLOG (Step 13) to persist GC'd states before removal

## Production Readiness Gaps

### Snapshot xip Linear Search

The current `is_txid_visible` uses `xip.contains()` which is O(n) in the number of concurrent transactions. For high-concurrency workloads:

- Use a sorted `Vec<TxId>` with binary search, or
- Use `HashSet<TxId>` for O(1) lookup

### Isolation Levels Beyond READ COMMITTED

Our `is_tuple_visible` implements READ COMMITTED (snapshot per statement). Other levels need different functions:

- **REPEATABLE READ**: Same snapshot for entire transaction
- **SERIALIZABLE**: Same as REPEATABLE READ + conflict detection
- **READ UNCOMMITTED**: See uncommitted changes (rarely useful)

### Visibility Map

For efficient VACUUM and Index-Only Scans, PostgreSQL maintains a Visibility Map (VM) that tracks which pages contain only tuples visible to all transactions. This will be relevant in Step 15 (VACUUM) and Step 17 (IndexScan).
