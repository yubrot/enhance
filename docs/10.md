# Week 18-19: Basic Executor & EXPLAIN

> Implement Volcano trait (`next() -> Option<Tuple>`), SeqScan (heap iteration with visibility check), Filter (WHERE evaluation), Projection (column selection), and EXPLAIN output for plan visualization.

# This Step I Learned

## The Volcano Model

The Volcano model (also called the iterator model) is the dominant execution model in relational databases. Each operator is a "pull-based" iterator that returns one tuple at a time via a `next()` method. This design enables:

- **Pipelining**: Tuples flow through the operator tree without materializing intermediate results
- **Composability**: Operators stack naturally—a Filter wraps a SeqScan, a Projection wraps a Filter
- **Memory efficiency**: Only one tuple per operator level needs to be in memory at once

```
                    ┌────────────────┐
                    │   Projection   │  ← next() returns projected tuple
                    └───────┬────────┘
                            │
                    ┌───────▼────────┐
                    │     Filter     │  ← next() skips non-matching tuples
                    └───────┬────────┘
                            │
                    ┌───────▼────────┐
                    │    SeqScan     │  ← next() fetches visible tuples from heap
                    └────────────────┘
```

Our `Executor` trait mirrors this design:

```rust
#[async_trait]
pub trait Executor: Send {
    async fn next(&mut self) -> Result<Option<Tuple>, ExecutorError>;
    fn schema(&self) -> &[OutputColumn];
    fn explain(&self, indent: usize) -> String;
}
```

The `async` nature allows operators to perform I/O (page fetches) without blocking the executor thread.

## Plan Operators

### SeqScan: The Foundation

SeqScan iterates through all tuples in a table's heap page(s), applying MVCC visibility checks:

```rust
async fn load_page(&mut self) -> Result<(), ExecutorError> {
    let guard = self.pool.fetch_page(self.first_page).await?;
    let page = HeapPage::new(guard.data());

    for (slot_id, header, record) in page.scan(&self.schema) {
        if self.snapshot.is_tuple_visible(&header, &self.tx_manager) {
            self.buffer.push(Tuple::new(record.values));
        }
    }
    Ok(())
}
```

Key design choice: we **buffer all visible tuples from a page** rather than yielding one at a time. This simplifies the state machine and ensures the page guard is released promptly. The trade-off is higher memory usage for pages with many visible tuples.

### Filter: Predicate Evaluation

Filter wraps a child executor and applies a WHERE predicate. The core loop is:

```rust
async fn next(&mut self) -> Result<Option<Tuple>, ExecutorError> {
    loop {
        match self.child.next().await? {
            Some(tuple) => {
                let result = evaluate(&self.predicate, &tuple.values, &self.columns)?;
                if is_truthy(&result) {
                    return Ok(Some(tuple));
                }
                // Filtered out—continue to next tuple
            }
            None => return Ok(None),
        }
    }
}
```

The `loop` is essential: Filter may need to skip many tuples before finding one that matches.

### Projection: Column Selection and Expression Evaluation

Projection computes output expressions from input tuples. For `SELECT id, name || '!' AS greeting`, it evaluates each expression against the input and produces a new tuple:

```rust
async fn next(&mut self) -> Result<Option<Tuple>, ExecutorError> {
    match self.child.next().await? {
        Some(tuple) => {
            let mut output = Vec::new();
            for (expr, _) in &self.output_exprs {
                output.push(evaluate(expr, &tuple.values, &self.columns)?);
            }
            Ok(Some(Tuple::new(output)))
        }
        None => Ok(None),
    }
}
```

## Expression Evaluation with SQL Semantics

SQL's three-valued logic (TRUE, FALSE, NULL) requires careful handling in expression evaluation.

### NULL Propagation

Most operators propagate NULL: `5 + NULL = NULL`, `NULL = NULL = NULL` (not TRUE!).

```rust
// For comparison, arithmetic, etc.
if left.is_null() || right.is_null() {
    return Ok(Value::Null);
}
```

### Short-Circuit Logic for AND/OR

AND and OR have special NULL handling that differs from simple propagation:

| AND       | TRUE  | FALSE | NULL  |
|-----------|-------|-------|-------|
| **TRUE**  | TRUE  | FALSE | NULL  |
| **FALSE** | FALSE | FALSE | FALSE |
| **NULL**  | NULL  | FALSE | NULL  |

| OR        | TRUE  | FALSE | NULL  |
|-----------|-------|-------|-------|
| **TRUE**  | TRUE  | TRUE  | TRUE  |
| **FALSE** | TRUE  | FALSE | NULL  |
| **NULL**  | TRUE  | NULL  | NULL  |

The key insight: `FALSE AND NULL = FALSE` because FALSE already determines the result regardless of the other operand. Similarly, `TRUE OR NULL = TRUE`.

```rust
fn eval_and(left: &Value, right: &Value) -> Result<Value, ExecutorError> {
    match (to_bool_or_null(left)?, to_bool_or_null(right)?) {
        (Some(false), _) | (_, Some(false)) => Ok(Value::Boolean(false)),
        (Some(true), Some(true)) => Ok(Value::Boolean(true)),
        _ => Ok(Value::Null),
    }
}
```

### Type Coercion

Comparisons and arithmetic between different numeric types require implicit coercion. Our strategy: promote to the "larger" type to avoid precision loss.

```rust
// Integer vs Float: promote integer to float
(Value::Int32(a), Value::Float64(b)) => {
    Ok((*a as f64).partial_cmp(b).unwrap_or(Ordering::Equal))
}
```

The `value.rs` module handles all combinations of Int16/Int32/Int64/Float32/Float64 comparisons and arithmetic—a verbose but straightforward approach.

## The Planner

The planner converts SQL AST to an executor tree. For this step, it's a direct translation without optimization:

```
SELECT id, name FROM users WHERE age > 21

        AST                          Executor Tree
    ┌─────────┐                    ┌─────────────┐
    │ SELECT  │                    │ Projection  │
    │ id,name │       ────►        │ [id, name]  │
    │ FROM    │                    └──────┬──────┘
    │ users   │                           │
    │ WHERE   │                    ┌──────▼──────┐
    │ age>21  │                    │   Filter    │
    └─────────┘                    │   age > 21  │
                                   └──────┬──────┘
                                          │
                                   ┌──────▼──────┐
                                   │   SeqScan   │
                                   │    users    │
                                   └─────────────┘
```

The `plan_select` function:
1. Validates unsupported features (JOINs, GROUP BY, ORDER BY, LIMIT)
2. Looks up table metadata in the catalog
3. Builds the projection (handles `SELECT *`, qualified wildcards, expressions)
4. Creates the executor tree bottom-up: SeqScan → Filter (if WHERE) → Projection

## EXPLAIN

EXPLAIN outputs the execution plan for query analysis. Each operator implements `explain()`:

```rust
fn explain(&self, indent: usize) -> String {
    format!("{}Seq Scan on {}", " ".repeat(indent), self.table_name)
}

// Filter's explain shows the predicate and recurses to child
fn explain(&self, indent: usize) -> String {
    format!(
        "{}Filter: {}\n{}",
        " ".repeat(indent),
        format_expr(&self.predicate),
        self.child.explain(indent + 2)
    )
}
```

Example output:
```
EXPLAIN SELECT * FROM users WHERE id > 5;
 Filter: (id > 5)
   Seq Scan on users
```

## Integration with Connection Handler

The executor integrates with the PostgreSQL protocol through the connection handler:

1. **RowDescription**: Send column metadata before data rows
2. **DataRow**: Stream tuples as they're produced by `executor.next()`
3. **CommandComplete**: Report row count after exhausting the iterator

```rust
// Send RowDescription
let fields = executor.schema().iter().map(|col| FieldDescription { ... });
self.framed.send(BackendMessage::RowDescription { fields }).await?;

// Stream rows
let mut row_count = 0;
while let Some(tuple) = executor.next().await? {
    let values = tuple.values.iter().map(value_to_data_value).collect();
    self.framed.send(BackendMessage::DataRow { values }).await?;
    row_count += 1;
}
```

This streaming approach means rows are sent to the client as they're produced—we don't buffer the entire result set.

# Looking Forward

## Immediate Dependencies

- **Step 11 (DML Operations)**: INSERT/UPDATE/DELETE executors will follow the same Volcano pattern
- **Step 12 (Sort & Aggregation)**: Sort requires materializing all input tuples before outputting (a "blocking" operator). Aggregate functions need accumulator state.

## Deferred: Multi-Page Tables

Tables are currently limited to a single page. The SeqScan state machine has a `ScanState` enum that's ready for multi-page iteration:

```rust
enum ScanState {
    NotStarted,
    Scanning,
    Finished,
}
```

Step 15 (FSM) will introduce page chaining, and SeqScan will need to track `current_page_id` and iterate through the chain.

## Deferred: Index Scan

Step 17 introduces B+Tree indexes and IndexScan. The planner will need rule-based logic to choose between SeqScan and IndexScan based on predicates.

## Production Readiness Gaps

### Buffering Strategy

Current approach: buffer all visible tuples from a page into `Vec<Tuple>`. For pages with thousands of tuples, this is memory-inefficient. Production options:
- Yield tuples one at a time, holding the page guard longer
- Configurable buffer size with partial page iteration

### Type Coercion Completeness

The current type coercion handles numeric types but lacks:
- Date/time arithmetic
- String-to-number coercion
- CAST expressions (Step 11)

### Error Position Tracking

Expression evaluation errors don't include source positions. Adding error context ("column 'age' in expression at position 42") would improve debugging.

### EXPLAIN ANALYZE

Current EXPLAIN shows the plan structure. EXPLAIN ANALYZE would execute the query and report actual row counts and timing per operator—useful for query tuning.

### Prepared Statement Analysis

The Extended Query Protocol's Describe message returns `NoData` instead of proper column metadata. Full implementation requires running the planner at Describe time to determine output schema.
